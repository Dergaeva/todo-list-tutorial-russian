# Компонент

Один из подходов в веб-разработке \(и разработка программного обеспечения в целом\) это компонентная архитектура. В последние годы он приобрел большую популярность. Что такое компонент?

В [Service-Oriented Architecture \(SOA\) vs. Component Based Architecture](http://petritsch.co.at/download/SOA_vs_component_based.pdf), Хельмут Петрич определяет компонент следующим образом:

> Компонент является программным объектом, предназначеный для взаимодействия с другими компонентами, инкапсулирования определенной функциональности или набора функций. Компонент имеет четко определенный интерфейс и соответствует предписанному поведению, характерному для всех компонентов в архитектуре.

В веб-приложениях, **компонент управляет участком экрана, называемым представлением**. Это часть того, что вы в конечном итоге увидите на экране. У него есть шаблон, который определяет его визуальную структуру. Он также имеет логику, которая определяет поведение и динамические значения. Логической частью является код JavaScript и называется контроллером.

Вот диаграмма компонента в Angular, с приведенным ниже результатом.

Директивы, pipes и сервисы - это другие строительные блоки в Angular, который может быть использован в компоненте \ (на диаграмме мы видим только использование pipe\). Мы обсудим их позже.

Давайте посмотрим на компонент, который был создан спомощью Angular CLI. Все необходимые файлы находятся в папке `src/app`. Открыть файл `app.component.ts`.

Как ngModulesкоторые мы видели в предыдущей главе, компонент также определяется классом с декоратором. Это определение класса:

{% code-tabs %}
{% code-tabs-item title="src/app/app.component.ts" %}
```typescript
export class AppComponent {
  title = 'app';
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

В нем есть один член, подназванием "title". Это свойство, которому вы можете присвоить значение. Значением, назначенным ему здесь, является строкой "app".

Angular выполняет синхронизацию элементов компонента с шаблоном компонента. Поэтому мы можем легко использовать элемент `title` в шаблоне. Взгляните на шаблон, прикрепленный к компоненту в файле `app.component.html`. В верхней части вы увидите следующий код:

{% code-tabs %}
{% code-tabs-item title="src/app/app.component.html" %}
```markup
<h1>
  Welcome to {{ title }}!
</h1>
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Двойные фигурные скобки и их содержимое называются **Интерполяция**. Это одна из форм **привязки данных** в Angular. Как мы уже упоминали, код в этом файле не используется, когда браузер отображает компонент. Angular компилирует его в код JavaScript. На одном из этапов компиляции он ищет интерполяции внутри шаблона. Содержание Интерполяции является "Angular выражением шаблона" \(который очень похож на JavaScript\). Выражение оценивается во время выполнения, а затем вы видите результат.

Интерполяция - одна из самых важных, наиболее основных функций в Angular. Она существовал с самого начала Angular - в первой версии \(AngularJS\). Она дает возможность просто вставить динамические данные в представление.

В этом компоненте, выражение является членом класса компонентов, `title`. **Попробуем изменить его.** Попробуйте следующее и посмотрите результат в браузере. \(С каждым изменением, которое вы делаете в файле, браузер автоматически обновится!\)

* Удалите фигурные скобки и сохраните только содержимое `title`.
* Верните фигурные скобки назад и замените содержимое некоторым математическим выражением, например: `{{ 2 + 2 }}`. \(Пробелы не являются обязательными, они просто делают код более читаемым.\)
* Напишите математическое выражение в сочетании с членом `title`: `{{ title + 10 }}`
* Передайте неопределенную переменную в выражение - переменную, которая не была объявлена в классе компонента. Например: `{{ x }}`
* Попробуйте все, что захотите. Не беспокойтесь - вы не сможете навредить браузеру или компьютеру! В худшем случае у браузера не хватит памяти и он зависнет. \(Но вам нужно написать что-то действительно сложное, чтобы это произошло!\)

Это один из способов, которым вы можете привязать элементы контроллера компонента к его шаблону. Как Angular знает, что это шаблон компонента приложения?

Вернемся к файлу  `app.component.ts` и посмотрим на метаданные компонента в декораторе `@Component`, прямо над определением класса:

{% code-tabs %}
{% code-tabs-item title="src/app/app.component.ts" %}
```typescript
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Мы передаем объект определения декоратору, как мы видели в предыдущей главе с ngModule. Второе свойство, `templateUrl`, сообщает Angular, где искать шаблон, прикрепленный к компоненту. Есть еще один вариант указать на шаблон, который мы обсудим позже: написать весь шаблон inline здесь, в определении компонента.

Третье свойство, `styleUrls`, сообщает Angular, где искать файлы CSS, которые определяют стиль этого компонента. Он может иметь несколько файлов CSS. Вот почему значение `styleUrls` является массивом. Если вы посмотрите файл CSS `app.component.css` - вы увидите, что он пуст. Здесь вы можете добавить стиль CSS, например:

{% code-tabs %}
{% code-tabs-item title="src/app/app.component.css" %}
```css
h1 {
  color: red;
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Мы добавим больше стилей позже

**Примечание:**  Angular CLI поддерживает языки css: sass, less, and stylus.

Первое свойство, `selector`, сообщает Angular, что будет именем тега, который мы будем использовать для вызова компонента. Как мы видели в файле `src / index.html`, мы используем компонент приложения внутри тела:

{% code-tabs %}
{% code-tabs-item title="src/index.html" %}
```markup
<body>
  <app-root></app-root>
</body>
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Элемент `app-root` не является элементом HTML. Это компонент, который был создан с помощью селектора `app-root`. Попробуйте изменить селектор. Вы увидите, что если вы измените его только в одном из файлов, ничего не будет отображаться, так как элемент больше не заменяется в компоненте Angular. Вы можете увидеть сообщение об ошибке в консоли браузера.

И последнее: первая строка в файле компонента импортирует код, определяющий декоратор `@Component`. Необходимо использовать декоратор, который определен в импортированном файле \ (или фактически, в одном из собственных импортов\). Попробуйте удалить эту строку и увидеть ошибку.

## Встроенный шаблон

Давайте переместим шаблон в **inline** в определение компонента. Это поможет нам управлять шаблоном, наблюдая за его функциональностью. В файле `app.component.ts` замените строку

{% code-tabs %}
{% code-tabs-item title="src/app/app.component.ts" %}
```typescript
templateUrl: './app.component.html',
```
{% endcode-tabs-item %}
{% endcode-tabs %}

with

{% code-tabs %}
{% code-tabs-item title="src/app/app.component.ts" %}
```typescript
template: ``,
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Обратите внимание на **обратные кавычки** - **\` **- они используются для определения литералов шаблонов, которые являются новыми в JavaScript \(ES6\). Таким образом вы можете определить многострочные строки. У них есть еще одна крутая способность: легко использовать переменные JavaScript и выражения внутри строки \(без отношения Angular к выражению привязки в шаблоне \). Читайте об этом в [MDN documentation](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals).

Убедитесь, что вы заменили `templateUrl` с `template`, и не забудьте запятую в конце строки.

Теперь вместо того, чтобы брать содержимое из исходного шаблона, мы добавим более простой шаблон, с которым будем работать. Когда курсор находится между обратными кавычками, нажмите Enter и вставьте шаблон HTML:

{% code-tabs %}
{% code-tabs-item title="src/app/app.component.ts" %}
```markup
template: `
  <h1>
    Welcome to {{ title }}!
  </h1>  
`,
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Легче управлять шаблоном, когда вы видите одновременно его контроллер. Это удобно, если шаблон не становится слишком большим, и контроллер не становится слишком сложным. Если так, это знак того, что вы должны реорганизовать свой код, разбив его на дочерние компоненты.

На этом этапе вы можете удалить файл `app.component.html`.

**Мы рекомендуем продолжить это учебное пособие, используя встроенные шаблоны в компонентах.** Особенно, если вы работаете на ноутбуке с маленьким экраном, где недостаточно места для открытия двух файлов бок о бок.

Давайте сконфигурируем Angular CLI, чтобы предоставить нам встроенный шаблон по умолчанию. В терминале выполните команду: `ng set defaults.component.inlineTemplate true`. Теперь каждый компонент, который вы создадите, будет иметь встроенный шаблон, и HTML-файл не будет создан.

Если вы хотите продолжить это руководство с помощью шаблонов в отдельных файлах HTML, не запускайте эту команду и используйте сгенерированные файлы `.html` для шаблонов.

> **Примечание: ** Вы можете указать, что вы хотите использовать встроенный шаблон во всем проекте несколькими способами:
>
> * При создании проекта передайте флаг `-it` или` -inline-template` следующим образом: `ng new todo-list -it`
> * После создания проекта добавьте его в конфигурацию, чтобы компоненты, сгенерированные с этого момента, имели встроенный шаблон: `ng set defaults.component.inlineTemplate true`. \(С версии 6 вам нужно будет использовать команду `ng config projects.YOURPROJECTNAME.schematics.@schematics/angular:component.inlineTemplate true`\) Это добавит строку `inlineTemplate: true` в конфигурационный файл Angular CLI `.angular-cli.json` \(`angular.json` в версии 6\). Вы также можете редактировать файл напрямую.
> * Если вы не настроили встроенные шаблоны по умолчанию, вы можете сделать это для каждого компонента при его создании, передав флаг `-it` или `--inline-template`. Например: `ng generate header -it`.

Точно так же, используя встроенный шаблон, мы можем вставлять встроенные стили. Но пока мы сохраним стили в отдельном файле.

## Резюме

Мы изучили корневой компонент, который был сгенерирован спомощью Angular CLI, и даже реорганизовали его. В следующей главе мы создадим новый компонент. Мы начнем строить дерево компонентов, которое определяет структуру приложения.

